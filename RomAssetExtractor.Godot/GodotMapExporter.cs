using RomAssetExtractor.Pokemon.Entities;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace RomAssetExtractor.Godot
{
    /// <summary>
    /// Exports ROM map data as a self-contained Godot 4.3+ project with
    /// TileSet (.tres), TileMap scene (.tscn), and per-map JSON files
    /// containing NPC/event data and animation metadata.
    ///
    /// Output structure (under maps/godot/):
    ///   project.godot              — Godot project file (open this folder in Godot)
    ///   tiles/                     — Tileset atlas PNGs
    ///   tilesets/                  — TileSet resources (.tres)
    ///   scenes/                    — Map scenes (.tscn)
    ///   data/                      — Per-map JSON (NPCs, warps, animation info)
    ///
    /// To use: open the godot/ folder as a project in Godot 4.3+.
    /// </summary>
    public static class GodotMapExporter
    {
        private const int ATLAS_COLUMNS = 8;
        private static readonly Encoding Utf8NoBom = new UTF8Encoding(false);

        public static void ExportAllMaps(Bank[] banks, string outputDirectory)
        {
            var godotRoot = Path.Combine(outputDirectory, "maps", "godot");
            var tilesDir = Path.Combine(godotRoot, "tiles");
            var tsDir = Path.Combine(godotRoot, "tilesets");
            var sceneDir = Path.Combine(godotRoot, "scenes");
            var dataDir = Path.Combine(godotRoot, "data");

            Directory.CreateDirectory(tilesDir);
            Directory.CreateDirectory(tsDir);
            Directory.CreateDirectory(sceneDir);
            Directory.CreateDirectory(dataDir);

            WriteProjectFile(godotRoot);

            var srcTilesDir = Path.Combine(outputDirectory, "maps", "tiles");
            int exported = 0;

            var usedNames = new Dictionary<string, int>();

            foreach (var bank in banks)
            {
                foreach (var map in bank.Maps)
                {
                    try
                    {
                        var srcPrefix = $"{bank.Id}.{map.Id}";
                        var cleanName = MakeSafeFileName(map.GetCleanLabel());
                        if (string.IsNullOrEmpty(cleanName))
                            cleanName = $"Map_{bank.Id}_{map.Id}";
                        else
                            cleanName = $"{cleanName}_{bank.Id}_{map.Id}";

                        // Safety: ensure no duplicates even if labels+IDs somehow collide
                        if (usedNames.ContainsKey(cleanName))
                        {
                            usedNames[cleanName]++;
                            cleanName = $"{cleanName}_dup{usedNames[cleanName]}";
                        }
                        else
                        {
                            usedNames[cleanName] = 1;
                        }

                        if (ExportMap(srcPrefix, cleanName, map, srcTilesDir, tilesDir, tsDir, sceneDir, dataDir))
                            exported++;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"  [Godot] WARNING: {bank.Id}.{map.Id} — {ex.Message}");
                    }
                }
            }

            Console.WriteLine($"  [Godot] Exported {exported} maps → {godotRoot}");
            Console.WriteLine($"  [Godot] Open the folder above as a Godot 4.3+ project.");
        }

        // ─────────── project.godot ───────────

        /// <summary>
        /// Only creates a project.godot if no parent directory already contains one.
        /// This avoids hiding the output from an existing Godot project.
        /// </summary>
        private static void WriteProjectFile(string godotRoot)
        {
            // If any ancestor directory already has a project.godot, skip creation
            var dir = Directory.GetParent(godotRoot);
            while (dir != null)
            {
                if (File.Exists(Path.Combine(dir.FullName, "project.godot")))
                {
                    // Remove a previously generated one if it exists (from earlier runs)
                    var oldPath = Path.Combine(godotRoot, "project.godot");
                    if (File.Exists(oldPath))
                    {
                        File.Delete(oldPath);
                        Console.WriteLine("  [Godot] Removed nested project.godot (parent Godot project detected).");
                    }
                    return;
                }
                dir = dir.Parent;
            }

            var path = Path.Combine(godotRoot, "project.godot");
            if (File.Exists(path)) return;

            var sb = new StringBuilder();
            sb.Append("; Godot project generated by ROM Asset Extractor\n");
            sb.Append("\n");
            sb.Append("config_version=5\n");
            sb.Append("\n");
            sb.Append("[application]\n");
            sb.Append("\n");
            sb.Append("config/name=\"Extracted Maps\"\n");
            sb.Append("config/features=PackedStringArray(\"4.3\")\n");
            sb.Append("\n");
            sb.Append("[rendering]\n");
            sb.Append("\n");
            sb.Append("textures/canvas_textures/default_texture_filter=0\n");

            File.WriteAllText(path, sb.ToString(), Utf8NoBom);
        }

        // ─────────── per-map export ───────────

        /// <summary>
        /// Convert a map label like "PALLET TOWN" into a safe filename like "Pallet_Town".
        /// </summary>
        private static string MakeSafeFileName(string label)
        {
            if (string.IsNullOrWhiteSpace(label)) return null;

            // Title-case each word: "PALLET TOWN" → "Pallet Town"
            var words = label.Trim().Split(new[] { ' ', '_', '-' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();
            foreach (var w in words)
            {
                if (sb.Length > 0) sb.Append('_');
                sb.Append(char.ToUpper(w[0]));
                if (w.Length > 1) sb.Append(w.Substring(1).ToLower());
            }

            // Remove anything that isn't letter, digit, or underscore
            var result = new StringBuilder();
            foreach (char c in sb.ToString())
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                    result.Append(c);
            }
            return result.Length > 0 ? result.ToString() : null;
        }

        private static bool ExportMap(
            string srcPrefix, string outName, Map map,
            string srcTilesDir, string dstTilesDir,
            string tsDir, string sceneDir, string dataDir)
        {
            var metatiles = map.Metatiles;
            if (metatiles == null) return false;

            int w = map.Layout.Width;
            int h = map.Layout.Height;
            if (w <= 0 || h <= 0) return false;

            int metatileCount = metatiles.TotalMetatileCount;

            // ── Copy tileset PNGs ──
            string srcGroundPng = $"{srcPrefix}_tileset.png";
            string srcOverlayPng = $"{srcPrefix}_tileset_overlays.png";
            string dstGroundPng = $"{outName}_tileset.png";
            string dstOverlayPng = $"{outName}_tileset_overlays.png";

            string srcGround = Path.Combine(srcTilesDir, srcGroundPng);
            if (!File.Exists(srcGround)) return false;

            CopyIfNewer(srcGround, Path.Combine(dstTilesDir, dstGroundPng));

            bool hasOverlay = false;
            string srcOverlay = Path.Combine(srcTilesDir, srcOverlayPng);
            if (File.Exists(srcOverlay))
            {
                CopyIfNewer(srcOverlay, Path.Combine(dstTilesDir, dstOverlayPng));
                hasOverlay = true;
            }

            // ── Write TileSet .tres ──
            string groundRelPath = "../tiles/" + dstGroundPng;
            string overlayRelPath = "../tiles/" + dstOverlayPng;
            WriteTileSetResource(
                Path.Combine(tsDir, $"{outName}_tileset.tres"),
                groundRelPath, overlayRelPath,
                metatileCount, hasOverlay);

            // ── Write Scene .tscn ──
            string tilesetRelPath = "../tilesets/" + outName + "_tileset.tres";
            WriteMapScene(
                Path.Combine(sceneDir, $"{outName}.tscn"),
                tilesetRelPath, map, metatiles, w, h, hasOverlay);

            // ── Write map data JSON (NPCs, warps, animation metadata) ──
            WriteMapDataJson(
                Path.Combine(dataDir, $"{outName}.json"),
                map, metatiles, w, h);

            return true;
        }

        // ═══════════ TileSet .tres ═══════════

        private static void WriteTileSetResource(
            string path,
            string groundTexPath, string overlayTexPath,
            int metatileCount,
            bool hasOverlay)
        {
            var sb = new StringBuilder(metatileCount * 40);

            int extRes = hasOverlay ? 2 : 1;
            int subRes = hasOverlay ? 2 : 1;
            int loadSteps = extRes + subRes + 1;

            L(sb, $"[gd_resource type=\"TileSet\" load_steps={loadSteps} format=3]");
            L(sb, "");

            // ext_resources — textures
            L(sb, $"[ext_resource type=\"Texture2D\" path=\"{groundTexPath}\" id=\"1\"]");
            if (hasOverlay)
                L(sb, $"[ext_resource type=\"Texture2D\" path=\"{overlayTexPath}\" id=\"2\"]");
            L(sb, "");

            // sub_resource — ground atlas
            L(sb, "[sub_resource type=\"TileSetAtlasSource\" id=\"TileSetAtlasSource_0\"]");
            L(sb, "resource_name = \"Ground\"");
            L(sb, "texture = ExtResource(\"1\")");
            L(sb, "texture_region_size = Vector2i(16, 16)");
            WriteTileEntries(sb, metatileCount);
            L(sb, "");

            // sub_resource — overlay atlas
            if (hasOverlay)
            {
                L(sb, "[sub_resource type=\"TileSetAtlasSource\" id=\"TileSetAtlasSource_1\"]");
                L(sb, "resource_name = \"Overlay\"");
                L(sb, "texture = ExtResource(\"2\")");
                L(sb, "texture_region_size = Vector2i(16, 16)");
                WriteTileEntries(sb, metatileCount);
                L(sb, "");
            }

            // main [resource]
            L(sb, "[resource]");
            L(sb, "tile_size = Vector2i(16, 16)");
            L(sb, "sources/0 = SubResource(\"TileSetAtlasSource_0\")");
            if (hasOverlay)
                L(sb, "sources/1 = SubResource(\"TileSetAtlasSource_1\")");

            File.WriteAllText(path, sb.ToString(), Utf8NoBom);
        }

        private static void WriteTileEntries(StringBuilder sb, int count)
        {
            for (int id = 0; id < count; id++)
            {
                int col = id % ATLAS_COLUMNS;
                int row = id / ATLAS_COLUMNS;
                L(sb, $"{col}:{row}/0 = 0");
            }
        }

        // ═══════════ Map Scene .tscn ═══════════

        private static void WriteMapScene(
            string path, string tilesetRelPath,
            Map map, MetatileLayout metatiles,
            int w, int h, bool hasOverlay)
        {
            string label = SanitizeNodeName(map.GetCleanLabel());

            var sb = new StringBuilder(w * h * 50);

            L(sb, "[gd_scene load_steps=2 format=3]");
            L(sb, "");
            L(sb, $"[ext_resource type=\"TileSet\" path=\"{tilesetRelPath}\" id=\"1\"]");
            L(sb, "");

            // Root
            L(sb, $"[node name=\"{label}\" type=\"Node2D\"]");
            L(sb, "");

            // Ground layer — source 0
            L(sb, "[node name=\"Ground\" type=\"TileMapLayer\" parent=\".\"]");
            L(sb, "tile_set = ExtResource(\"1\")");
            L(sb, "texture_filter = 1");
            sb.Append("tile_map_data = ");
            WriteTileMapData(sb, metatiles, w, h, sourceId: 0);
            sb.Append('\n');
            L(sb, "");

            // Overlay layer — source 1
            if (hasOverlay)
            {
                L(sb, "[node name=\"Overlay\" type=\"TileMapLayer\" parent=\".\"]");
                L(sb, "tile_set = ExtResource(\"1\")");
                L(sb, "texture_filter = 1");
                sb.Append("tile_map_data = ");
                WriteTileMapData(sb, metatiles, w, h, sourceId: 1);
                sb.Append('\n');
            }

            File.WriteAllText(path, sb.ToString(), Utf8NoBom);
        }

        /// <summary>
        /// Godot 4.3 TileMapLayer tile_map_data — PackedByteArray, 12 bytes per cell.
        /// Godot 4.3+ requires a 2-byte format version header before cells.
        /// </summary>
        private static void WriteTileMapData(
            StringBuilder sb, MetatileLayout mt,
            int w, int h, int sourceId)
        {
            const ushort TILE_MAP_DATA_FORMAT = 0;

            int total = w * h;
            var buf = new byte[2 + total * 12];
            int off = 0;

            Put16(buf, off, TILE_MAP_DATA_FORMAT);
            off += 2;

            for (int y = 0; y < h; y++)
            {
                for (int x = 0; x < w; x++)
                {
                    int idx = y * w + x;
                    int tileId = mt.GetTileId(idx);
                    int ax = tileId % ATLAS_COLUMNS;
                    int ay = tileId / ATLAS_COLUMNS;

                    Put16(buf, off + 0, (ushort)x);
                    Put16(buf, off + 2, (ushort)y);
                    Put16(buf, off + 4, (ushort)sourceId);
                    Put16(buf, off + 6, (ushort)ax);
                    Put16(buf, off + 8, (ushort)ay);
                    Put16(buf, off + 10, 0);

                    off += 12;
                }
            }

            sb.Append("PackedByteArray(");
            for (int i = 0; i < buf.Length; i++)
            {
                if (i > 0) sb.Append(", ");
                sb.Append(buf[i]);
            }
            sb.Append(')');
        }

        // ═══════════ Map Data JSON ═══════════

        /// <summary>
        /// Writes a JSON file per map containing:
        ///   - NPC / object events (sprite id, position, movement, trainer info, flag)
        ///   - Warp events (position, destination map/warp)
        ///   - Trigger / coordinate events (position, script offset)
        ///   - Sign / BG events (position, type, script offset)
        ///   - Tileset animation callback pointers (for cross-ref with decomp projects)
        ///   - Map header metadata (music, weather, type, etc.)
        /// </summary>
        private static void WriteMapDataJson(
            string path, Map map, MetatileLayout metatiles,
            int w, int h)
        {
            var sb = new StringBuilder(4096);
            sb.Append("{\n");

            // ── Map header ──
            sb.Append("  \"mapLabel\": "); JsonString(sb, map.GetCleanLabel()); sb.Append(",\n");
            sb.Append($"  \"bankId\": {map.BankId},\n");
            sb.Append($"  \"mapId\": {map.Id},\n");
            sb.Append($"  \"width\": {w},\n");
            sb.Append($"  \"height\": {h},\n");
            sb.Append($"  \"musicId\": {map.Header.MusicId},\n");
            sb.Append($"  \"weatherType\": {map.Header.WeatherType},\n");
            sb.Append($"  \"mapType\": {(int)map.Header.MapType},\n");
            sb.Append($"  \"escapeRope\": {map.Header.EscapeRope},\n");
            sb.Append($"  \"battleScene\": {(int)map.Header.BattleType},\n");

            // ── Animation metadata ──
            int primaryCb = metatiles.PrimaryAnimationCallback;
            int secondaryCb = metatiles.SecondaryAnimationCallback;
            sb.Append("  \"tilesetAnimations\": {\n");
            sb.Append($"    \"primaryCallback\": \"0x{primaryCb:X8}\",\n");
            sb.Append($"    \"secondaryCallback\": \"0x{secondaryCb:X8}\",\n");
            sb.Append($"    \"hasAnimations\": {(primaryCb != 0 || secondaryCb != 0 ? "true" : "false")}\n");
            sb.Append("  },\n");

            // ── NPC / Object events ──
            var events = map.Events;
            sb.Append("  \"npcs\": [\n");
            if (events != null && events.ObjectEvents != null)
            {
                for (int i = 0; i < events.ObjectEvents.Length; i++)
                {
                    var o = events.ObjectEvents[i];
                    sb.Append("    {\n");
                    sb.Append($"      \"localId\": {o.LocalId},\n");
                    sb.Append($"      \"graphicsId\": {o.GraphicsId},\n");
                    sb.Append($"      \"kind\": {o.Kind},\n");
                    sb.Append($"      \"x\": {o.X},\n");
                    sb.Append($"      \"y\": {o.Y},\n");
                    sb.Append($"      \"elevation\": {o.Elevation},\n");
                    sb.Append($"      \"movementType\": {o.MovementType},\n");
                    sb.Append($"      \"movementRangeX\": {o.RangeXY & 0x0F},\n");
                    sb.Append($"      \"movementRangeY\": {(o.RangeXY >> 4) & 0x0F},\n");
                    sb.Append($"      \"trainerType\": {o.TrainerType},\n");
                    sb.Append($"      \"trainerRange\": {o.TrainerRange},\n");
                    sb.Append($"      \"scriptOffset\": \"0x{o.Script.TargetOffsetNormalized:X8}\",\n");
                    sb.Append($"      \"flagId\": {o.FlagId}\n");
                    sb.Append(i < events.ObjectEvents.Length - 1 ? "    },\n" : "    }\n");
                }
            }
            sb.Append("  ],\n");

            // ── Warp events ──
            sb.Append("  \"warps\": [\n");
            if (events != null && events.Warps != null)
            {
                for (int i = 0; i < events.Warps.Length; i++)
                {
                    var wp = events.Warps[i];
                    sb.Append("    {\n");
                    sb.Append($"      \"x\": {wp.X},\n");
                    sb.Append($"      \"y\": {wp.Y},\n");
                    sb.Append($"      \"elevation\": {wp.Elevation},\n");
                    sb.Append($"      \"destWarpId\": {wp.WarpId},\n");
                    sb.Append($"      \"destMapNum\": {wp.DestMapNum},\n");
                    sb.Append($"      \"destMapGroup\": {wp.DestMapGroup}\n");
                    sb.Append(i < events.Warps.Length - 1 ? "    },\n" : "    }\n");
                }
            }
            sb.Append("  ],\n");

            // ── Trigger / coordinate events ──
            sb.Append("  \"triggers\": [\n");
            if (events != null && events.CoordEvents != null)
            {
                for (int i = 0; i < events.CoordEvents.Length; i++)
                {
                    var ce = events.CoordEvents[i];
                    sb.Append("    {\n");
                    sb.Append($"      \"x\": {ce.X},\n");
                    sb.Append($"      \"y\": {ce.Y},\n");
                    sb.Append($"      \"elevation\": {ce.Elevation},\n");
                    sb.Append($"      \"trigger\": {ce.Trigger},\n");
                    sb.Append($"      \"index\": {ce.Index},\n");
                    sb.Append($"      \"scriptOffset\": \"0x{ce.Script.TargetOffsetNormalized:X8}\"\n");
                    sb.Append(i < events.CoordEvents.Length - 1 ? "    },\n" : "    }\n");
                }
            }
            sb.Append("  ],\n");

            // ── Sign / BG events ──
            sb.Append("  \"signs\": [\n");
            if (events != null && events.BgEvents != null)
            {
                for (int i = 0; i < events.BgEvents.Length; i++)
                {
                    var bg = events.BgEvents[i];
                    sb.Append("    {\n");
                    sb.Append($"      \"x\": {bg.X},\n");
                    sb.Append($"      \"y\": {bg.Y},\n");
                    sb.Append($"      \"elevation\": {bg.Elevation},\n");
                    sb.Append($"      \"kind\": {bg.Kind},\n");
                    sb.Append($"      \"dataOffset\": \"0x{bg.Data.TargetOffsetNormalized:X8}\"\n");
                    sb.Append(i < events.BgEvents.Length - 1 ? "    },\n" : "    }\n");
                }
            }
            sb.Append("  ]\n");

            sb.Append("}\n");

            File.WriteAllText(path, sb.ToString(), Utf8NoBom);
        }

        // ─────────── tiny helpers ───────────

        private static void Put16(byte[] b, int o, ushort v)
        {
            b[o] = (byte)(v & 0xFF);
            b[o + 1] = (byte)(v >> 8);
        }

        /// <summary>Append a line using LF only (no CR).</summary>
        private static void L(StringBuilder sb, string line)
        {
            sb.Append(line);
            sb.Append('\n');
        }

        /// <summary>Append a JSON-escaped string value (with quotes).</summary>
        private static void JsonString(StringBuilder sb, string value)
        {
            if (value == null) { sb.Append("null"); return; }
            sb.Append('"');
            foreach (char c in value)
            {
                switch (c)
                {
                    case '"': sb.Append("\\\""); break;
                    case '\\': sb.Append("\\\\"); break;
                    case '\n': sb.Append("\\n"); break;
                    case '\r': sb.Append("\\r"); break;
                    case '\t': sb.Append("\\t"); break;
                    default: sb.Append(c); break;
                }
            }
            sb.Append('"');
        }

        private static string SanitizeNodeName(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return "Map";
            var sb = new StringBuilder(name.Length);
            foreach (char c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_') sb.Append(c);
                else if (c == ' ' || c == '-') sb.Append('_');
            }
            var result = sb.ToString().Trim('_');
            return string.IsNullOrEmpty(result) ? "Map" : result;
        }

        private static void CopyIfNewer(string src, string dst)
        {
            if (File.Exists(dst) &&
                File.GetLastWriteTimeUtc(dst) >= File.GetLastWriteTimeUtc(src))
                return;

            File.Copy(src, dst, overwrite: true);
        }
    }
}
